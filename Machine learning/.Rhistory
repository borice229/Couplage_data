library(RMySQL)
# Charger les packages
library(DBI)
library(RMySQL)
# Établir la connexion
con <- dbConnect(RMySQL::MySQL(),
dbname = "MachineL",  # Nom de la base de données
host = "127.0.0.1",    # Adresse locale du serveur MySQL
port = 3306,           # Port par défaut pour MySQL
user = "root",         # Nom d'utilisateur
password = "less@intsARS19") # Mot de passe réel
# Établir la connexion
con <- dbConnect(RMySQL::MySQL(),
dbname = "Mlearn",  # Nom de la base de données
host = "127.0.0.1",    # Adresse locale du serveur MySQL
port = 3306,           # Port par défaut pour MySQL
user = "root",         # Nom d'utilisateur
password = "less@intsARS19") # Mot de passe réel
# Vérification de la connexion
if (!is.null(con)) {
cat("Connexion réussie à la base de données 'mlearning' !\n")
} else {
cat("Erreur lors de la connexion.\n")
}
# Créer la table Parameters
dbExecute(con, "
CREATE TABLE IF NOT EXISTS Parameters (
id INT AUTO_INCREMENT PRIMARY KEY,
a FLOAT NOT NULL,
b FLOAT NOT NULL,
c FLOAT NOT NULL,
U0 FLOAT NOT NULL
)
")
# Générer les colonnes U1 à U40
columns <- paste0("U", 1:N, " FLOAT NOT NULL")
columns_sql <- paste(columns, collapse = ",\n    ")
# Script SQL complet
query <- paste0("
CREATE TABLE IF NOT EXISTS NormalData (
id INT AUTO_INCREMENT PRIMARY KEY,
parameter_id INT NOT NULL,
", columns_sql, ",
FOREIGN KEY (parameter_id) REFERENCES Parameters(id) ON DELETE CASCADE
)
")
# Afficher le script pour vérification
#cat(query)
# Exécuter le script sur la base de données
dbExecute(con, query)
# Script SQL complet
query <- paste0("
CREATE TABLE IF NOT EXISTS NoiseData (
id INT AUTO_INCREMENT PRIMARY KEY,
parameter_id INT NOT NULL,
", columns_sql, ",
FOREIGN KEY (parameter_id) REFERENCES Parameters(id) ON DELETE CASCADE
)
")
# Exécuter le script sur la base de données
dbExecute(con, query)
View(Main_Learning_Base)
sim_Uo
# Nombre de simulations
M <- 10 # Ajustez ce nombre selon vos besoins
N <- 5   # Nombre d'itérations pour Generate_output
# Simulation des paramètres
sim_a <- round(rnorm(M, mean = 3, sd = 0.2), 2)  # Simulation des paramètres a
sim_b <- round(rnorm(M, mean = 4, sd = 0.3), 2)  # Simulation des paramètres b
sim_c <- round(rnorm(M, mean = 0.6, sd = 0.05), 2)  # Simulation des paramètres c
sim_U0 <- round(runif(M, min = 1, max = 10), 2)  # Simulation des valeurs initiales de U0
# Définition de la fonction Generate_output
Generate_output <- function(N, a, b, c, U0) {
U <- numeric(N + 1)
U[1] <- U0
for (n in 1:N) {
U[n + 1] <- a * U[n]^c + b
}
return(U)
}
# Génération des résultats et création de la DataFrame
results <- data.frame(
a = sim_a,
b = sim_b,
c = sim_c,
U0 = sim_U0
)
# Calcul des sorties Un et ajout comme une colonne
results$Un <- apply(results, 1, function(row) {
Generate_output(N, row["a"], row["b"], row["c"], row["U0"])
})
results
results <- data.frame(
a = sim_a,
b = sim_b,
c = sim_c,
U0 = sim_U0
)
View(results)
Calcul des sorties Un et ajout comme une colonne
results$Un <- apply(results, 1, function(row) {
Generate_output(N, row["a"], row["b"], row["c"], row["U0"])
})
results$Un <- lapply(1:nrow(results), function(i) {
Generate_output(N, results$a[i], results$b[i], results$c[i], results$U0[i])
})
# Nombre de simulations
M <- 100 # Ajustez ce nombre selon vos besoins
N <- 40   # Nombre d'itérations pour Generate_output
# Simulation des paramètres
sim_a <- round(rnorm(M, mean = 3, sd = 0.2), 2)  # Simulation des paramètres a
sim_b <- round(rnorm(M, mean = 4, sd = 0.3), 2)  # Simulation des paramètres b
sim_c <- round(rnorm(M, mean = 0.6, sd = 0.05), 2)  # Simulation des paramètres c
sim_U0 <- round(runif(M, min = 1, max = 10), 2)  # Simulation des valeurs initiales de U0
# Définition de la fonction Generate_output
Generate_output <- function(N, a, b, c, U0) {
U <- numeric(N + 1)
U[1] <- U0
for (n in 1:N) {
U[n + 1] <- a * U[n]^c + b
}
return(U)
}
# Génération des résultats et création de la DataFrame
results <- data.frame(
a = sim_a,
b = sim_b,
c = sim_c,
U0 = sim_U0
)
# Calcul des sorties Un et ajout comme une colonne
# Calcul des sorties Un et ajout comme une colonne
results$Un <- lapply(1:nrow(results), function(i) {
Generate_output(N, results$a[i], results$b[i], results$c[i], results$U0[i])
})
# Affichage de la DataFrame
head(results)
# Nombre de simulations
M <- 100 # Ajustez ce nombre selon vos besoins
N <- 40   # Nombre d'itérations pour Generate_output
# Simulation des paramètres
sim_a <- round(rnorm(M, mean = 3, sd = 0.2), 2)  # Simulation des paramètres a
sim_b <- round(rnorm(M, mean = 4, sd = 0.3), 2)  # Simulation des paramètres b
sim_c <- round(rnorm(M, mean = 0.6, sd = 0.05), 2)  # Simulation des paramètres c
sim_U0 <- round(runif(M, min = 1, max = 10), 2)  # Simulation des valeurs initiales de U0
# Génération des résultats et création de la DataFrame
Output_Curves <- data.frame(
a = sim_a,
b = sim_b,
c = sim_c,
U0 = sim_U0
)
# Calcul des sorties Un et ajout comme une colonne
# Calcul des sorties Un et ajout comme une colonne
Output_Curves$Un <- lapply(1:nrow(results), function(i) {
Generate_output(N, Output_Curves$a[i], Output_Curves$b[i], Output_Curves$c[i], Output_Curves$U0[i])
})
# Affichage de la DataFrame
head(Output_Curves)
View(Output_Curves)
# Nombre de simulations
M <- 100 # Ajustez ce nombre selon vos besoins
N <- 40   # Nombre d'itérations pour Generate_output
# Simulation des paramètres
sim_a <- round(rnorm(M, mean = 3, sd = 0.2), 2)  # Simulation des paramètres a
sim_b <- round(rnorm(M, mean = 4, sd = 0.3), 2)  # Simulation des paramètres b
sim_c <- round(rnorm(M, mean = 0.6, sd = 0.05), 2)  # Simulation des paramètres c
sim_U0 <- round(runif(M, min = 1, max = 10), 2)  # Simulation des valeurs initiales de U0
# Génération des résultats et création de la DataFrame
Main_Learning_Base <- data.frame(
a = sim_a,
b = sim_b,
c = sim_c,
U0 = sim_U0
)
# Calcul des sorties Un et ajout comme une colonne
# Calcul des sorties Un et ajout comme une colonne
Main_Learning_Base$Un <- lapply(1:nrow(Main_Learning_Base), function(i) {
Generate_output(N, Main_Learning_Base$a[i], Main_Learning_Base$b[i], Main_Learning_Base$c[i], Main_Learning_Base$U0[i]) + rnorm(N+1,mean=0,sd=1)
})
# Affichage de la DataFrame
head(Main_Learning_Base)
# Créer la table Parameters
dbExecute(con, "
CREATE TABLE IF NOT EXISTS Parameters (
id INT AUTO_INCREMENT PRIMARY KEY,
a FLOAT NOT NULL,
b FLOAT NOT NULL,
c FLOAT NOT NULL,
U0 FLOAT NOT NULL
)
")
# Créer la table NormalData
dbExecute(con, "
CREATE TABLE IF NOT EXISTS NormalData (
id INT AUTO_INCREMENT PRIMARY KEY,
parameter_id INT NOT NULL,
Un JSON NOT NULL,
FOREIGN KEY (parameter_id) REFERENCES Parameters(id) ON DELETE CASCADE
)
")
# Créer la table NoiseData
dbExecute(con, "
CREATE TABLE IF NOT EXISTS NoiseData (
id INT AUTO_INCREMENT PRIMARY KEY,
parameter_id INT NOT NULL,
Un JSON NOT NULL,
FOREIGN KEY (parameter_id) REFERENCES Parameters(id) ON DELETE CASCADE
)
")
param<-Main_Learning_Base[, 1:4]
View(param)
# Charger les données dans la table Parameters
dbWriteTable(con, "Parameters", param, row.names = FALSE, append = TRUE)
# Vider la table Parameters avant d'ajouter de nouvelles données
dbExecute(con, "TRUNCATE TABLE Parameters")
# Désactiver les contraintes de clé étrangère
dbExecute(con, "SET foreign_key_checks = 0")
# Vider la table Parameters
dbExecute(con, "TRUNCATE TABLE Parameters")
# Réactiver les contraintes de clé étrangère
dbExecute(con, "SET foreign_key_checks = 1")
# Vider la table Parameters avant d'ajouter de nouvelles données
dbExecute(con, "TRUNCATE TABLE Parameters")
# Vider la table Parameters avant d'ajouter de nouvelles données
#dbExecute(con, "TRUNCATE TABLE Parameters")
# Charger les nouvelles données dans la table Parameters
dbWriteTable(con, "Parameters", param, row.names = FALSE, append = TRUE)
# Désactiver les contraintes de clé étrangère
dbExecute(con, "SET foreign_key_checks = 0")
# Vider la table Parameters
dbExecute(con, "TRUNCATE TABLE Parameters")
# Réactiver les contraintes de clé étrangère
dbExecute(con, "SET foreign_key_checks = 1")
# Désactiver les contraintes de clé étrangère
dbExecute(con, "SET foreign_key_checks = 0")
# Vider la table Parameters
dbExecute(con, "TRUNCATE TABLE Parameters")
# Réactiver les contraintes de clé étrangère
dbExecute(con, "SET foreign_key_checks = 1")
# Charger les nouvelles données dans la table Parameters
dbWriteTable(con, "Parameters", param, row.names = FALSE, append = TRUE)
# Désactiver les contraintes de clé étrangère
dbExecute(con, "SET foreign_key_checks = 0")
# Supprimer la table Parameters si elle existe déjà
dbExecute(con, "DROP TABLE IF EXISTS Parameters")
# Créer à nouveau la table Parameters
dbExecute(con, "
CREATE TABLE Parameters (
id INT AUTO_INCREMENT PRIMARY KEY,
a FLOAT NOT NULL,
b FLOAT NOT NULL,
c FLOAT NOT NULL,
U0 FLOAT NOT NULL
)
")
# Réactiver les contraintes de clé étrangère
dbExecute(con, "SET foreign_key_checks = 1")
# Charger les nouvelles données dans la table Parameters
dbWriteTable(con, "Parameters", param, row.names = FALSE, append = TRUE)
# Désactiver les contraintes de clé étrangère
dbExecute(con, "SET foreign_key_checks = 0")
# Vérifier si la table Parameters existe
if (dbExistsTable(con, "Parameters")) {
# Supprimer la table Parameters si elle existe
dbExecute(con, "DROP TABLE IF EXISTS Parameters")
}
# Créer à nouveau la table Parameters
dbExecute(con, "
CREATE TABLE Parameters (
id INT AUTO_INCREMENT PRIMARY KEY,
a FLOAT NOT NULL,
b FLOAT NOT NULL,
c FLOAT NOT NULL,
U0 FLOAT NOT NULL
)
")
# Désactiver les contraintes de clé étrangère
dbExecute(con, "SET foreign_key_checks = 0")
# Vérifier si la table Parameters existe
if (dbExistsTable(con, "Parameters")) {
# Supprimer la table Parameters si elle existe
dbExecute(con, "DROP TABLE IF EXISTS Parameters")
}
# Créer à nouveau la table Parameters
dbExecute(con, "
CREATE TABLE Parameters (
id INT AUTO_INCREMENT PRIMARY KEY,
a FLOAT NOT NULL,
b FLOAT NOT NULL,
c FLOAT NOT NULL,
U0 FLOAT NOT NULL
)
")
# Réactiver les contraintes de clé étrangère
dbExecute(con, "SET foreign_key_checks = 1")
# Charger les nouvelles données dans la table Parameters
dbWriteTable(con, "Parameters", param, row.names = FALSE, append = TRUE)
# Désactiver les contraintes de clé étrangère
dbExecute(con, "SET foreign_key_checks = 0")
# Vérifier si la table Parameters existe
if (dbExistsTable(con, "Parameters")) {
# Supprimer la table Parameters si elle existe
dbExecute(con, "DROP TABLE IF EXISTS Parameters")
}
# Créer à nouveau la table Parameters
dbExecute(con, "
CREATE TABLE Parameters (
id INT AUTO_INCREMENT PRIMARY KEY,
a FLOAT NOT NULL,
b FLOAT NOT NULL,
c FLOAT NOT NULL,
U0 FLOAT NOT NULL
)
")
# Réactiver les contraintes de clé étrangère
dbExecute(con, "SET foreign_key_checks = 1")
# Charger les nouvelles données dans la table Parameters
dbWriteTable(con, "Parameters", param, row.names = FALSE, append = TRUE)
# Désactiver les contraintes de clé étrangère
dbExecute(con, "SET foreign_key_checks = 0")
# Vérifier si la table Parameters existe déjà
if (dbExistsTable(con, "Parameters")) {
# Supprimer la table Parameters si elle existe
dbExecute(con, "DROP TABLE Parameters")
}
# Créer la table Parameters
dbExecute(con, "
CREATE TABLE Parameters (
id INT AUTO_INCREMENT PRIMARY KEY,
a FLOAT NOT NULL,
b FLOAT NOT NULL,
c FLOAT NOT NULL,
U0 FLOAT NOT NULL
)
")
# Créer la table Parameters
dbExecute(con, "
CREATE TABLE IF NOT EXISTS Parameters (
id INT AUTO_INCREMENT PRIMARY KEY,
a FLOAT NOT NULL,
b FLOAT NOT NULL,
c FLOAT NOT NULL,
U0 FLOAT NOT NULL
)
")
# Charger les nouvelles données dans la table Parameters
dbWriteTable(con, "Parameters", param, row.names = FALSE, append = FALSE)
# Préparer les données à insérer, en excluant l'`id`
for (i in 1:nrow(param)) {
query <- sprintf("INSERT INTO Parameters (a, b, c, U0) VALUES (%f, %f, %f, %f)",
param$a[i], param$b[i], param$c[i], param$U0[i])
dbExecute(con, query)
}
# Créer la table NormalData
dbExecute(con, "
CREATE TABLE IF NOT EXISTS NormalData (
id INT AUTO_INCREMENT PRIMARY KEY,
parameter_id INT NOT NULL,
Un JSON NOT NULL,
FOREIGN KEY (parameter_id) REFERENCES Parameters(id) ON DELETE CASCADE
)
")
# Supposons que votre dataframe Output_Curves contient les colonnes suivantes :
# - parameter_id (ID des paramètres dans la table Parameters)
# - Un (la liste des résultats que vous voulez insérer sous format JSON)
# Préparer les données à insérer dans NormalData
for (i in 1:nrow(Output_Curves)) {
# Convertir la colonne Un en format JSON
un_json <- jsonlite::toJSON(Output_Curves$Un[i], auto_unbox = TRUE)
# Construire la requête SQL d'insertion
query <- sprintf("INSERT INTO NormalData (parameter_id, Un) VALUES (%d, '%s')",
Output_Curves$parameter_id[i], un_json)
# Exécuter la requête d'insertion
dbExecute(con, query)
}
# Créer la table NormalData
dbExecute(con, "
CREATE TABLE IF NOT EXISTS NormalData (
id INT AUTO_INCREMENT PRIMARY KEY,
parameter_id INT AUTO_INCREMENT,
U0 FLOAT,
Un JSON NOT NULL,
FOREIGN KEY (parameter_id) REFERENCES Parameters(id) ON DELETE CASCADE
)
")
# Créer la colonne 'parameter_id' qui contient des valeurs de 1 à N
Output_Curves$parameter_id <- 1:nrow(Output_Curves)
View(Output_Curves)
# Préparer les données à insérer, en excluant l'`id`
for (i in 1:nrow(Output_Curves)) {
query <- sprintf("INSERT INTO NormalData (parameter_id, Un) VALUES (%f, %f)",
Output_Curves$parameter_id[i], Output_Curves$Un[i])
dbExecute(con, query)
}
# Créer la table NormalData
dbExecute(con, "
CREATE TABLE IF NOT EXISTS NormalData (
id INT AUTO_INCREMENT PRIMARY KEY,
parameter_id INT AUTO_INCREMENT,
U0 FLOAT,
Un JSON NOT NULL,
FOREIGN KEY (parameter_id) REFERENCES Parameters(id) ON DELETE CASCADE
)
")
# Créer la table NormalData
dbExecute(con, "
CREATE TABLE IF NOT EXISTS NormalData (
id INT NOT NULL,
parameter_id INT AUTO_INCREMENT,
Un JSON NOT NULL,
FOREIGN KEY (parameter_id) REFERENCES Parameters(id) ON DELETE CASCADE
)
")
# Préparer les données à insérer, en excluant l'`id`
for (i in 1:nrow(Output_Curves)) {
query <- sprintf("INSERT INTO NormalData (parameter_id, Un) VALUES (%f, %f)",
Output_Curves$parameter_id[i], Output_Curves$Un[i])
dbExecute(con, query)
}
# Créer la table NormalData
dbExecute(con, "
CREATE TABLE IF NOT EXISTS NormalData (
id INT AUTO_INCREMENT,
parameter_id INT NOT NULL ,
Un JSON NOT NULL,
FOREIGN KEY (parameter_id) REFERENCES Parameters(id) ON DELETE CASCADE
)
")
# Créer la table NormalData
dbExecute(con, "
CREATE TABLE IF NOT EXISTS NormalData (
id INT AUTO_INCREMENT,
parameter_id INT NOT NULL ,
Un JSON NOT NULL,
FOREIGN KEY (parameter_id) REFERENCES Parameters(id) ON DELETE CASCADE
)
")
# Créer la table NormalData avec l'ID comme clé primaire et la clé étrangère pour parameter_id
dbExecute(con, "
CREATE TABLE IF NOT EXISTS NormalData (
id INT AUTO_INCREMENT PRIMARY KEY,  -- Définir id comme clé primaire
parameter_id INT NOT NULL,          -- Clé étrangère
Un JSON NOT NULL,                   -- Colonne JSON pour stocker Un
FOREIGN KEY (parameter_id) REFERENCES Parameters(id) ON DELETE CASCADE  -- Référence à Parameters
)
")
# Préparer les données à insérer, en excluant l'`id`
for (i in 1:nrow(Output_Curves)) {
query <- sprintf("INSERT INTO NormalData (parameter_id, Un) VALUES (%f, %f)",
Output_Curves$parameter_id[i], Output_Curves$Un[i])
dbExecute(con, query)
}
# Charger la bibliothèque jsonlite pour la conversion en JSON
library(jsonlite)
# Préparer les données à insérer dans la table NormalData
for (i in 1:nrow(Output_Curves)) {
# Convertir la colonne Un en chaîne JSON
Un_json <- toJSON(Output_Curves$Un[[i]], auto_unbox = TRUE)  # auto_unbox pour convertir en un tableau JSON correct
# Construire la requête SQL
query <- sprintf("INSERT INTO NormalData (parameter_id, Un) VALUES (%d, '%s')",
Output_Curves$parameter_id[i], Un_json)  # '%s' pour insérer la chaîne JSON
# Exécuter la requête d'insertion
dbExecute(con, query)
}
# Créer la colonne 'parameter_id' qui contient des valeurs de 1 à N
Main_Learning_Base$parameter_id <- 1:nrow(Main_Learning_Base)
# Charger la bibliothèque jsonlite pour la conversion en JSON
library(jsonlite)
# Préparer les données à insérer dans la table NormalData
for (i in 1:nrow(Main_Learning_Base)) {
# Convertir la colonne Un en chaîne JSON
Un_j <- toJSON(Main_Learning_Base$Un[[i]], auto_unbox = TRUE)  # auto_unbox pour convertir en un tableau JSON correct
# Construire la requête SQL
query <- sprintf("INSERT INTO NormalData (parameter_id, Un) VALUES (%d, '%s')",
Main_Learning_Base$parameter_id[i], Un_j)  # '%s' pour insérer la chaîne JSON
# Exécuter la requête d'insertion
dbExecute(con, query)
}
# Créer la table NoiseData
dbExecute(con, "
CREATE TABLE IF NOT EXISTS NoiseData (
id INT AUTO_INCREMENT PRIMARY KEY,
parameter_id INT NOT NULL,
Un JSON NOT NULL,
FOREIGN KEY (parameter_id) REFERENCES Parameters(id) ON DELETE CASCADE
)
")
# Charger la bibliothèque jsonlite pour la conversion en JSON
library(jsonlite)
# Préparer les données à insérer dans la table NormalData
for (i in 1:nrow(Main_Learning_Base)) {
# Convertir la colonne Un en chaîne JSON
Un_j <- toJSON(Main_Learning_Base$Un[[i]], auto_unbox = TRUE)  # auto_unbox pour convertir en un tableau JSON correct
# Construire la requête SQL
query <- sprintf("INSERT INTO NoiseData (parameter_id, Un) VALUES (%d, '%s')",
Main_Learning_Base$parameter_id[i], Un_j)  # '%s' pour insérer la chaîne JSON
# Exécuter la requête d'insertion
dbExecute(con, query)
}
# Charger la bibliothèque jsonlite pour la conversion en JSON
library(jsonlite)
# Préparer les données à insérer dans la table NormalData
for (i in 1:nrow(Output_Curves)) {
# Convertir la colonne Un en chaîne JSON
Un_json <- toJSON(Output_Curves$Un[[i]], auto_unbox = TRUE)  # auto_unbox pour convertir en un tableau JSON correct
# Construire la requête SQL
query <- sprintf("INSERT INTO NormalData (parameter_id, Un) VALUES (%d, '%s')",
Output_Curves$parameter_id[i], Un_json)  # '%s' pour insérer la chaîne JSON
# Exécuter la requête d'insertion
dbExecute(con, query)
}
