color = "Individu") +
theme_minimal()
library(ggplot2)
library(reshape2)
library(dplyr)
# Simulation des paramètres pour n individus
set.seed(123)  # Pour la reproductibilité
M <- 100  # Nombre d'individus
N <- 40  # Nombre d'itérations
# Simulation des paramètres a, b, c, et U0
sim_a <- round(rnorm(M, mean = 3, sd = 0.2), 2)  # Simulation des paramètres a
sim_b <- round(rnorm(M, mean = 4, sd = 0.3), 2)  # Simulation des paramètres b
sim_c <- round(rnorm(M, mean = 0.6, sd = 0.05), 2)  # Simulation des paramètres c
sim_Uo <- round(runif(M, min = 1, max = 10), 2)  # Simulation des valeurs initiales de U0
# Générer une base de données avec les valeurs de a, b, c et U[0], U[1], ..., U[N]
base_root <- data.frame(matrix(ncol = N + 4, nrow = M))  # Base vide (n lignes, N+4 colonnes)
# Noms des colonnes : a, b, c, U[0], ..., U[100]
colnames(base_root) <- c("a", "b", "c", paste0("U", 0:N))
# Remplir la base avec les valeurs simulées de a, b, c et les valeurs de U
for (i in 1:M) {
base_root[i, 1] <- sim_a[i]  # Valeur de a
base_root[i, 2] <- sim_b[i]  # Valeur de b
base_root[i, 3] <- sim_c[i]  # Valeur de c
base_root[i, 4] <- sim_Uo[i]  # Valeur de Uo
# Calculer les valeurs de U à l'aide de la fonction Generate_output (assurez-vous qu'elle est définie)
U_values <- round(Generate_output(N, sim_a[i], sim_b[i], sim_c[i], sim_Uo[i]), 2)
# Ajouter les valeurs de U dans la base
base_root[i, 4:(N + 4)] <- U_values
}
# Restructurer les données pour le graphique
base_root %>%
mutate(Individu = 1:M) %>%               # Ajouter la colonne 'Individu'
melt(id.vars = c("a", "b", "c", "Individu"),
variable.name = "Iteration",
value.name = "U") %>%                # Restructurer le dataframe
mutate(Iteration = as.numeric(gsub("U", "", Iteration))) %>%  # Convertir la colonne 'Iteration' en numérique
ggplot(aes(x = Iteration, y = U, color = factor(Individu))) + # Graphique ggplot
geom_line(linewidth = 1) +                     # Remplacer 'size' par 'linewidth'
labs(title = "Évolution de U[n] pour chaque individu",
x = "Itération (N)",
y = "Valeur de U[N]",
color = "Individu") +
theme_minimal()
View(base_root)
# Générer une base de données avec les valeurs de a, b, c et U[0], U[1], ..., U[100]
base_brutee <- data.frame(matrix(ncol = N + 4, nrow = M))  # Base vide (n lignes, N+4 colonnes)
# Noms des colonnes : a, b, c, U[0], ..., U[100]
colnames(base_brutee) <- c("a", "b", "c", paste0("U", 0:N))
# Remplir la base avec les valeurs simulées de a, b, c et les valeurs de U
for (i in 1:M) {
base_brutee[i, 1] <- sim_a[i]  # Valeur de a
base_brutee[i, 2] <- sim_b[i]  # Valeur de b
base_brutee[i, 3] <- sim_c[i]  # Valeur de c
base_brutee[i, 4] <- sim_Uo[i]  # Valeur de Uo
U_values_bruité <- Generate_output(N, sim_a[i], sim_b[i], sim_c[i], sim_Uo[i])+  rnorm(1, mean = 0, sd = 1)  # Générer U[0] à U[100] bruité
base_brutee[i, 4:(N + 4)] <- U_values_bruité  # Remplir les colonnes U[0] à U[100]
}
base_brutee %>%
mutate(Individu = 1:M) %>%               # Ajouter la colonne 'Individu'
melt(id.vars = c("a", "b", "c", "Individu"),
variable.name = "Iteration",
value.name = "U") %>%                # Restructurer le dataframe
mutate(Iteration = as.numeric(gsub("U", "", Iteration))) %>%  # Convertir la colonne 'Iteration' en numérique
ggplot(aes(x = Iteration, y = U, color = factor(Individu))) + # Graphique ggplot
geom_line(size = 1) +                     # Tracer les courbes pour chaque individu
labs(title = "Évolution de U[n] bruité pour chaque individu",
x = "Itération (N)",
y = "Valeur de U[N]",
color = "Individu") +
theme_minimal()
U_values_bruité <- Generate_output_with_noise(N, sim_a[i], sim_b[i], sim_c[i], sim_Uo[i])  # Générer U[0] à U[100] bruité
U_values_bruité <- Generate_output_with_noise(N, sim_a[i], sim_b[i], sim_c[i], sim_Uo[i])  # Générer
# Définition de la fonction avec ajout de bruit
Generate_output_with_noise <- function(N, a, b, c, U0) {
U <- numeric(N + 1)
U[1] <- U0
for (n in 1:N) {
# Calcul de U[n+1] avec ajout de bruit gaussien
U[n + 1] <- a * U[n]^c + b + rnorm(1, mean = 0, sd = 1)
}
return(U)
}
# Générer une base de données avec les valeurs de a, b, c et U[0], U[1], ..., U[100]
base_brutee <- data.frame(matrix(ncol = N + 4, nrow = M))  # Base vide (n lignes, N+4 colonnes)
# Noms des colonnes : a, b, c, U[0], ..., U[100]
colnames(base_brutee) <- c("a", "b", "c", paste0("U", 0:N))
# Remplir la base avec les valeurs simulées de a, b, c et les valeurs de U
for (i in 1:M) {
base_brutee[i, 1] <- sim_a[i]  # Valeur de a
base_brutee[i, 2] <- sim_b[i]  # Valeur de b
base_brutee[i, 3] <- sim_c[i]  # Valeur de c
base_brutee[i, 4] <- sim_Uo[i]  # Valeur de Uo
U_values_bruité <- Generate_output_with_noise(N, sim_a[i], sim_b[i], sim_c[i], sim_Uo[i])  # Générer
base_brutee[i, 4:(N + 4)] <- U_values_bruité  # Remplir les colonnes U[0] à U[100]
}
base_brutee %>%
mutate(Individu = 1:M) %>%               # Ajouter la colonne 'Individu'
melt(id.vars = c("a", "b", "c", "Individu"),
variable.name = "Iteration",
value.name = "U") %>%                # Restructurer le dataframe
mutate(Iteration = as.numeric(gsub("U", "", Iteration))) %>%  # Convertir la colonne 'Iteration' en numérique
ggplot(aes(x = Iteration, y = U, color = factor(Individu))) + # Graphique ggplot
geom_line(size = 1) +                     # Tracer les courbes pour chaque individu
labs(title = "Évolution de U[n] bruité pour chaque individu",
x = "Itération (N)",
y = "Valeur de U[N]",
color = "Individu") +
theme_minimal()
View(base_brutee)
base_brutee[i, 4:(N + 4)] <- round(U_values_bruité,2)  # Remplir les colonnes U[0] à U[100]
# Définition de la fonction avec ajout de bruit
Generate_output_with_noise <- function(N, a, b, c, U0) {
U <- numeric(N + 1)
U[1] <- U0
for (n in 1:N) {
# Calcul de U[n+1] avec ajout de bruit gaussien
U[n + 1] <- a * U[n]^c + b + rnorm(1, mean = 0, sd = 1)
}
return(U)
}
# Générer une base de données avec les valeurs de a, b, c et U[0], U[1], ..., U[100]
base_brutee <- data.frame(matrix(ncol = N + 4, nrow = M))  # Base vide (n lignes, N+4 colonnes)
# Noms des colonnes : a, b, c, U[0], ..., U[100]
colnames(base_brutee) <- c("a", "b", "c", paste0("U", 0:N))
# Remplir la base avec les valeurs simulées de a, b, c et les valeurs de U
for (i in 1:M) {
base_brutee[i, 1] <- sim_a[i]  # Valeur de a
base_brutee[i, 2] <- sim_b[i]  # Valeur de b
base_brutee[i, 3] <- sim_c[i]  # Valeur de c
base_brutee[i, 4] <- sim_Uo[i]  # Valeur de Uo
U_values_bruité <- Generate_output_with_noise(N, sim_a[i], sim_b[i], sim_c[i], sim_Uo[i])  # Générer
base_brutee[i, 4:(N + 4)] <- round(U_values_bruité,2)  # Remplir les colonnes U[0] à U[100]
}
base_brutee %>%
mutate(Individu = 1:M) %>%               # Ajouter la colonne 'Individu'
melt(id.vars = c("a", "b", "c", "Individu"),
variable.name = "Iteration",
value.name = "U") %>%                # Restructurer le dataframe
mutate(Iteration = as.numeric(gsub("U", "", Iteration))) %>%  # Convertir la colonne 'Iteration' en numérique
ggplot(aes(x = Iteration, y = U, color = factor(Individu))) + # Graphique ggplot
geom_line(size = 1) +                     # Tracer les courbes pour chaque individu
labs(title = "Évolution de U[n] bruité pour chaque individu",
x = "Itération (N)",
y = "Valeur de U[N]",
color = "Individu") +
theme_minimal()
set.seed(123)  # Pour la reproductibilité
Output_Curves<-base_root[, 5:(N + 4)]
matrice_bruit_aleatoire <- matrix(rnorm(M * N), nrow = M, ncol = N)
Main_Learning_Base<-Output_Curves+matrice_bruit_aleatoire
View(Main_Learning_Base)
rm(list=ls())
library(tidyverse)
library(doParallel)
no_cores <- detectCores() - 1
source("~/Couplage_data/Machine learning/Gilles_durieux_20_11.R", echo=TRUE)
CV <- function(x,Xi,Yi,h,noy="G"){
Nada_Wat<-data(cbind(h,mapply(Nada_wa, x,Xi,Yi,h,noy="G")))
N<-length(h)
cv<-rep(0,N)
for (i in N ){
cv <-sum((Yi -Nada_Wat[i,2])^2)
}
return (stock<-which.min(cbind(h,cv)))
}
# Calcul pour différents h (h=0.5, h=0.1 et h=0.01)
h <- 0.05
resu1 <- NULL
for(i in 1: n)
{
resu1[i] = Nada_wa(data$xi[i],data$xi,data$yi,h)
}
lines(data$xi,resu1,col="yellow",lty=1)
h<-rnorm(10,mean=0,sd=0.01)
CV(data$xi[1],data$xi,data$yi,h)
source("~/Couplage_data/Machine learning/version2_11_durieu.R", echo=TRUE)
rm(list=ls())
source("~/Couplage_data/Machine learning/version2_11_durieu.R", echo=TRUE)
View(data)
data
# Estimateur de la densité de x
dens <- function(x,X,h,noy="G")
{
n <- length(data$x)
if (noy=="G")
noyau=gauss
if (noy=="R")
noyau=rectangle
if (noy=="T")
noyau=triangle
dXh <- (x-X)/h
num <- sum( noyau(dXh))
res <- num/(n*h)
return(res)
}
# Estimateur de la variance conditionnelle var(Y/X=x)
varcond <- function(x,X,Y,h,noy="G")
{
n <- length(data$x)
if (noy=="G")
noyau=gauss
if (noy=="R")
noyau=rectangle
if (noy=="T")
noyau=triangle
dXh <- (x-X)/h
num <- sum( noyau(dXh)*(Y-NW(x,X,Y,h,noy)))^2
res <- num/(n*h)
return(res)
}
# Estimateur de la variance conditionnelle var(Y/X=x)
varcond <- function(x,X,Y,h,noy="G")
{
n <- length(data$x)
if (noy=="G")
noyau=gauss
if (noy=="R")
noyau=rectangle
if (noy=="T")
noyau=triangle
dXh <- (x-X)/h
num <- sum( noyau(dXh)*(Y-NW(x,X,Y,h,noy))^2)
res <- num/dens(x,X,h,noy)
return(res)
}
noy<-"G"
noy
h<-0.01
n<-1000
noy<-"G"
alpha <- 0.05
z_alpha <- qnorm(1 - alpha / 2)
IC_lower<-NULL
IC_upper<- NULL
estNW<-NULL
for(i in 1: n)
{
sigma2[i]<- (varcond(data$x[i],data$x,data$y,h,noy=noy)*tau_g^2)/dens(data$x[i],data$x,data$y,h,noy=noy)
erreur_standard[i]<- sqrt(sigma2[i]/n*h)
estNW[i]<- NW(data$x[i],data$x,data$y,h,noy)
IC_lower[i] <- estNW[i] - z_alpha * erreur_standard[i]
IC_upper[i] <- estNW[i] + z_alpha * erreur_standard[i]
}
h<-0.01
n<-1000
noy<-"G"
alpha <- 0.05
z_alpha <- qnorm(1 - alpha / 2)
IC_lower<-NULL
IC_upper<- NULL
estNW<-NULL
for(i in 1: n)
{
sigma2[i]<- (varcond(data$x[i],data$x,data$y,h,noy=noy)*tau_g^2)/dens(data$x[i],data$x,h,noy=noy)
erreur_standard[i]<- sqrt(sigma2[i]/n*h)
estNW[i]<- NW(data$x[i],data$x,data$y,h,noy)
IC_lower[i] <- estNW[i] - z_alpha * erreur_standard[i]
IC_upper[i] <- estNW[i] + z_alpha * erreur_standard[i]
}
h<-0.01
n<-1000
noy<-"G"
alpha <- 0.05
z_alpha <- qnorm(1 - alpha / 2)
IC_lower<-NULL
IC_upper<- NULL
estNW<-NULL
sigma2<-NULL
for(i in 1: n)
{
sigma2[i]<- (varcond(data$x[i],data$x,data$y,h,noy=noy)*tau_g^2)/dens(data$x[i],data$x,h,noy=noy)
erreur_standard[i]<- sqrt(sigma2[i]/n*h)
estNW[i]<- NW(data$x[i],data$x,data$y,h,noy)
IC_lower[i] <- estNW[i] - z_alpha * erreur_standard[i]
IC_upper[i] <- estNW[i] + z_alpha * erreur_standard[i]
}
h<-0.01
n<-1000
noy<-"G"
alpha <- 0.05
z_alpha <- qnorm(1 - alpha / 2)
IC_lower<-NULL
IC_upper<- NULL
estNW<-NULL
sigma2<-NULL
erreur_standard<-NULL
for(i in 1: n)
{
sigma2[i]<- (varcond(data$x[i],data$x,data$y,h,noy=noy)*tau_g^2)/dens(data$x[i],data$x,h,noy=noy)
erreur_standard[i]<- sqrt(sigma2[i]/n*h)
estNW[i]<- NW(data$x[i],data$x,data$y,h,noy)
IC_lower[i] <- estNW[i] - z_alpha * erreur_standard[i]
IC_upper[i] <- estNW[i] + z_alpha * erreur_standard[i]
}
MatInt <- cbind(data$x,data$y,estNW,IC_lower,IC_upper)
View(MatInt)
colnames(MatInt) <- c("x", "y", "estimationNW", "IC_lower", "IC_upper")
library(ggplot2)
# Convertir la matrice MatInt en DataFrame pour ggplot2
MatInt_df <- as.data.frame(MatInt)
# Tracer l'estimateur et les intervalles de confiance
ggplot(MatInt_df, aes(x = x)) +
geom_line(aes(y = estimation, color = "Estimateur"), size = 1) + # Ligne estimateur
geom_ribbon(aes(ymin = IC_lower, ymax = IC_upper, fill = "Intervalle de confiance"), alpha = 0.3) + # Intervalle
labs(
title = "Estimateur avec Intervalle de Confiance",
x = "x",
y = "Valeur"
) +
scale_color_manual(
name = "Légende",
values = c("Estimateur" = "red")
) +
scale_fill_manual(
name = "Intervalle",
values = c("Intervalle de confiance" = "gray")
) +
theme_minimal()
# Tracer l'estimateur et les intervalles de confiance
ggplot(MatInt_df, aes(x = x)) +
geom_line(aes(y = estimation, color = "Estimateur"), size = 1) + # Ligne estimateur
geom_ribbon(aes(ymin = IC_lower, ymax = IC_upper, fill = "Intervalle de confiance"), alpha = 0.3) + # Intervalle
labs(
title = "Estimateur avec Intervalle de Confiance",
x = "x",
y = "Valeur"
) +
scale_color_manual(
name = "Légende",
values = c("Estimateur" = "red")
) +
scale_fill_manual(
name = "Intervalle",
values = c("Intervalle de confiance" = "gray")
) +
theme_minimal()
# Tracer l'estimateur et les intervalles de confiance
ggplot(MatInt_df, aes(x = x)) +
geom_line(aes(y = estimationNW, color = "Estimateur"), size = 1) + # Ligne estimateur
geom_ribbon(aes(ymin = IC_lower, ymax = IC_upper, fill = "Intervalle de confiance"), alpha = 0.3) + # Intervalle
labs(
title = "Estimateur avec Intervalle de Confiance",
x = "x",
y = "Valeur"
) +
scale_color_manual(
name = "Légende",
values = c("Estimateur" = "red")
) +
scale_fill_manual(
name = "Intervalle",
values = c("Intervalle de confiance" = "gray")
) +
theme_minimal()
View(MatInt_df)
# Supposons que MatInt est déjà défini avec les bonnes colonnes
colnames(MatInt) <- c("x", "y", "estimation", "IC_lower", "IC_upper")
# Convertir la matrice MatInt en DataFrame pour ggplot2
MatInt_df <- as.data.frame(MatInt)
# Tracer
ggplot(MatInt_df, aes(x = x)) +
# Nuages de points (x, y)
geom_point(aes(y = y, color = "Observations"), size = 2) +
# Courbe pour l'estimateur
geom_line(aes(y = estimation, color = "Estimateur"), size = 1) +
# Ruban pour les intervalles de confiance
geom_ribbon(aes(ymin = IC_lower, ymax = IC_upper, fill = "Intervalle de confiance"), alpha = 0.3) +
# Labels et thème
labs(
title = "Estimateur avec Intervalle de Confiance et Observations",
x = "x",
y = "Valeur"
) +
# Personnalisation des couleurs et de la légende
scale_color_manual(
name = "Légende",
values = c("Observations" = "blue", "Estimateur" = "red")
) +
scale_fill_manual(
name = "Intervalle",
values = c("Intervalle de confiance" = "gray")
) +
theme_minimal()
# Tracer
ggplot(MatInt_df, aes(x = x)) +
# Nuages de points (x, y)
geom_point(aes(y = y, color = "Observations"), size = 2) +
# Courbe pour l'estimateur
geom_line(aes(y = estimation, color = "Estimateur"), size = 1) +
# Ruban pour les intervalles de confiance
geom_ribbon(aes(ymin = IC_lower, ymax = IC_upper, fill = "Intervalle de confiance"), alpha = 0.3) +
# Labels et thème
labs(
title = "Estimateur avec Intervalle de Confiance et Observations",
x = "x",
y = "Valeur"
) +
# Personnalisation des couleurs et de la légende
scale_color_manual(
name = "Légende",
values = c("Observations" = "blue", "Estimateur" = "red")
) +
scale_fill_manual(
name = "Intervalle",
values = c("Intervalle de confiance" = "yellow")
) +
theme_minimal()
# Tracer
ggplot(MatInt_df, aes(x = x)) +
# Nuages de points (x, y)
geom_point(aes(y = y, color = "Observations"), size = 2) +
# Courbe pour l'estimateur
geom_line(aes(y = estimation, color = "Estimateur"), size = 1) +
# Ruban pour les intervalles de confiance
geom_ribbon(aes(ymin = IC_lower, ymax = IC_upper, fill = "Intervalle de confiance"), alpha = 1) +
# Labels et thème
labs(
title = "Estimateur avec Intervalle de Confiance et Observations",
x = "x",
y = "Valeur"
) +
# Personnalisation des couleurs et de la légende
scale_color_manual(
name = "Légende",
values = c("Observations" = "blue", "Estimateur" = "red")
) +
scale_fill_manual(
name = "Intervalle",
values = c("Intervalle de confiance" = "yellow")
) +
theme_minimal()
# Tracer
ggplot(MatInt_df, aes(x = x)) +
# Nuages de points (x, y)
geom_point(aes(y = y, color = "Observations"), size = 2) +
# Courbe pour l'estimateur
geom_line(aes(y = estimation, color = "Estimateur"), size = 1) +
# Ruban pour les intervalles de confiance
geom_ribbon(aes(ymin = IC_lower, ymax = IC_upper), alpha = 1) +
# Labels et thème
labs(
title = "Estimateur avec Intervalle de Confiance et Observations",
x = "x",
y = "Valeur"
) +
# Personnalisation des couleurs et de la légende
scale_color_manual(
name = "Légende",
values = c("Observations" = "blue", "Estimateur" = "red")
) +
scale_fill_manual(
name = "Intervalle",
values = c("Intervalle de confiance" = "yellow")
) +
theme_minimal()
# Tracer
ggplot(MatInt_df, aes(x = x)) +
# Nuages de points (x, y)
geom_point(aes(y = y, color = "Observations"), size = 2) +
# Courbe pour l'estimateur
geom_line(aes(y = estimation, color = "Estimateur"), size = 1) +
# Ruban pour les intervalles de confiance
geom_ribbon(aes(ymin = IC_lower, ymax = IC_upper), alpha = 1) +
# Labels et thème
labs(
title = "Estimateur avec Intervalle de Confiance et Observations",
x = "x",
y = "Valeur"
) +
# Personnalisation des couleurs et de la légende
scale_color_manual(
name = "Légende",
values = c("Observations" = "blue", "Estimateur" = "red")
) +
scale_fill_manual(
name = "Intervalle"
) +
theme_minimal()
# Convertir la matrice MatInt en DataFrame pour ggplot2
MatInt_df <- as.data.frame(MatInt)
# Tracer
ggplot(MatInt_df, aes(x = x)) +
# Nuages de points (x, y)
geom_point(aes(y = y, color = "Observations"), size = 2) +
# Courbe pour l'estimateur
geom_line(aes(y = estimation, color = "Estimateur"), size = 1) +
# Ruban pour les intervalles de confiance
geom_ribbon(aes(ymin = IC_lower, ymax = IC_upper, fill = "Intervalle de confiance"), alpha = 0.3) +
# Courbes pour IC_lower et IC_upper
geom_line(aes(y = IC_lower, color = "IC_lower"), linetype = "dashed", size = 0.8) +
geom_line(aes(y = IC_upper, color = "IC_upper"), linetype = "dashed", size = 0.8) +
# Labels et thème
labs(
title = "Estimateur avec Intervalle de Confiance et Observations",
x = "x",
y = "Valeur"
) +
# Personnalisation des couleurs et de la légende
scale_color_manual(
name = "Légende",
values = c(
"Observations" = "blue",
"Estimateur" = "red",
"IC_lower" = "green",
"IC_upper" = "purple"
)
) +
scale_fill_manual(
name = "Intervalle",
values = c("Intervalle de confiance" = "gray")
) +
theme_minimal()
