# Construire la requête SQL
query <- sprintf("INSERT INTO NoiseData (parameter_id, Un) VALUES (%d, '%s')",
Main_Learning_Base$parameter_id[i], Un_j)  # '%s' pour insérer la chaîne JSON
# Exécuter la requête d'insertion
dbExecute(con, query)
}
# Charger la bibliothèque jsonlite pour la conversion en JSON
library(jsonlite)
# Préparer les données à insérer dans la table NormalData
for (i in 1:nrow(Output_Curves)) {
# Convertir la colonne Un en chaîne JSON
Un_json <- toJSON(Output_Curves$Un[[i]], auto_unbox = TRUE)  # auto_unbox pour convertir en un tableau JSON correct
# Construire la requête SQL
query <- sprintf("INSERT INTO NormalData (parameter_id, Un) VALUES (%d, '%s')",
Output_Curves$parameter_id[i], Un_json)  # '%s' pour insérer la chaîne JSON
# Exécuter la requête d'insertion
dbExecute(con, query)
}
# Créer la colonne 'parameter_id' qui contient des valeurs de 1 à N
Output_Curves$parameter_id <- 1:nrow(Output_Curves)
# Préparer les données à insérer dans la table NormalData
for (i in 1:nrow(Output_Curves)) {
# Convertir la colonne Un en chaîne JSON
Un_json <- toJSON(Output_Curves$Un[[i]], auto_unbox = TRUE)  # auto_unbox pour convertir en un tableau JSON correct
# Construire la requête SQL
query <- sprintf("INSERT INTO NormalData (parameter_id, Un) VALUES (%d, '%s')",
Output_Curves$parameter_id[i], Un_json)  # '%s' pour insérer la chaîne JSON
# Exécuter la requête d'insertion
dbExecute(con, query)
}
library(ggplot2)
library(tidyr)
library(tidyverse)
library(reshape2)
library(dplyr)
library(DBI)
library(RMySQL)
library(jsonlite)
library(ggplot2)
library(tidyr)
library(tidyverse)
library(reshape2)
library(dplyr)
library(DBI)
library(RMySQL)
library(jsonlite)
# Générer une base de données avec les valeurs de a, b, c et U[0], U[1], ..., U[100]
base_brutee <- data.frame(matrix(ncol = N + 4, nrow = M))  # Base vide (n lignes, N+4 colonnes)
# Noms des colonnes : a, b, c, U[0], ..., U[100]
colnames(base_brutee) <- c("a", "b", "c", paste0("U", 0:N))
# Remplir la base avec les valeurs simulées de a, b, c et les valeurs de U
for (i in 1:M) {
base_brutee[i, 1] <- sim_a[i]  # Valeur de a
base_brutee[i, 2] <- sim_b[i]  # Valeur de b
base_brutee[i, 3] <- sim_c[i]  # Valeur de c
base_brutee[i, 4] <- sim_Uo[i]  # Valeur de Uo
U_values_bruité <- Generate_output(N, sim_a[i], sim_b[i], sim_c[i], sim_Uo[i]) + rnorm(N+1, mean = 0, sd = 1) # Générer
base_brutee[i, 4:(N + 4)] <- round(U_values_bruité,2)  # Remplir les colonnes U[0] à U[100]
}
base_brutee %>%
mutate(Individu = 1:M) %>%               # Ajouter la colonne 'Individu'
melt(id.vars = c("a", "b", "c", "Individu"),
variable.name = "Iteration",
value.name = "U") %>%                # Restructurer le dataframe
mutate(Iteration = as.numeric(gsub("U", "", Iteration))) %>%  # Convertir la colonne 'Iteration' en numérique
ggplot(aes(x = Iteration, y = U, color = factor(Individu))) + # Graphique ggplot
geom_line(size = 1) +                     # Tracer les courbes pour chaque individu
labs(title = "Évolution de U[n] bruité pour chaque individu",
x = "Itération (N)",
y = "Valeur de U[N]",
color = "Individu") +
theme_minimal()
# Générer une base de données avec les valeurs de a, b, c et U[0], U[1], ..., U[100]
base_brutee <- data.frame(matrix(ncol = N + 4, nrow = M))  # Base vide (n lignes, N+4 colonnes)
# Noms des colonnes : a, b, c, U[0], ..., U[100]
colnames(base_brutee) <- c("a", "b", "c", paste0("U", 0:N))
# Remplir la base avec les valeurs simulées de a, b, c et les valeurs de U
for (i in 1:M) {
base_brutee[i, 1] <- sim_a[i]  # Valeur de a
base_brutee[i, 2] <- sim_b[i]  # Valeur de b
base_brutee[i, 3] <- sim_c[i]  # Valeur de c
base_brutee[i, 4] <- sim_Uo[i]  # Valeur de Uo
U_values_bruité <- Generate_output(N, sim_a[i], sim_b[i], sim_c[i], sim_Uo[i]) + rnorm(N+1, mean = 0, sd = 1) # Générer
base_brutee[i, 4:(N + 4)] <- round(U_values_bruité,2)  # Remplir les colonnes U[0] à U[100]
}
base_brutee %>%
mutate(Individu = 1:M) %>%               # Ajouter la colonne 'Individu'
melt(id.vars = c("a", "b", "c", "Individu"),
variable.name = "Iteration",
value.name = "U") %>%                # Restructurer le dataframe
mutate(Iteration = as.numeric(gsub("U", "", Iteration))) %>%  # Convertir la colonne 'Iteration' en numérique
ggplot(aes(x = Iteration, y = U, color = factor(Individu))) + # Graphique ggplot
geom_line(size = 1) +                     # Tracer les courbes pour chaque individu
labs(title = "Évolution de U[n] bruité pour chaque individu",
x = "Itération (N)",
y = "Valeur de U[N]",
color = "Individu") +
theme_minimal()
set.seed(123)  # Pour la reproductibilité
# Générer une base de données avec les valeurs de a, b, c et U[0], U[1], ..., U[100]
base_brutee <- data.frame(matrix(ncol = N + 4, nrow = M))  # Base vide (n lignes, N+4 colonnes)
# Noms des colonnes : a, b, c, U[0], ..., U[100]
colnames(base_brutee) <- c("a", "b", "c", paste0("U", 0:N))
# Remplir la base avec les valeurs simulées de a, b, c et les valeurs de U
for (i in 1:M) {
base_brutee[i, 1] <- sim_a[i]  # Valeur de a
base_brutee[i, 2] <- sim_b[i]  # Valeur de b
base_brutee[i, 3] <- sim_c[i]  # Valeur de c
base_brutee[i, 4] <- sim_Uo[i]  # Valeur de Uo
U_values_bruité <- Generate_output(N, sim_a[i], sim_b[i], sim_c[i], sim_Uo[i]) + rnorm(N+1, mean = 0, sd = 1) # Générer
base_brutee[i, 4:(N + 4)] <- round(U_values_bruité,2)  # Remplir les colonnes U[0] à U[100]
}
base_brutee %>%
mutate(Individu = 1:M) %>%               # Ajouter la colonne 'Individu'
melt(id.vars = c("a", "b", "c", "Individu"),
variable.name = "Iteration",
value.name = "U") %>%                # Restructurer le dataframe
mutate(Iteration = as.numeric(gsub("U", "", Iteration))) %>%  # Convertir la colonne 'Iteration' en numérique
ggplot(aes(x = Iteration, y = U, color = factor(Individu))) + # Graphique ggplot
geom_line(size = 1) +                     # Tracer les courbes pour chaque individu
labs(title = "Évolution de U[n] bruité pour chaque individu",
x = "Itération (N)",
y = "Valeur de U[N]",
color = "Individu") +
theme_minimal()
# Créer la colonne 'parameter_id' qui contient des valeurs de 1 à N
Output_Curves$parameter_id <- 1:nrow(Output_Curves)
# Préparer les données à insérer dans la table NormalData
for (i in 1:nrow(Output_Curves)) {
# Convertir la colonne Un en chaîne JSON
Un_json <- toJSON(Output_Curves$Un[[i]], auto_unbox = TRUE)  # auto_unbox pour convertir en un tableau JSON correct
# Construire la requête SQL
query <- sprintf("INSERT INTO NormalData (parameter_id, Un) VALUES (%d, '%s')",
Output_Curves$parameter_id[i], Un_json)  # '%s' pour insérer la chaîne JSON
# Exécuter la requête d'insertion
dbExecute(con, query)
}
# Établir la connexion
con <- dbConnect(RMySQL::MySQL(),
dbname = "Mlearn",  # Nom de la base de données
host = "127.0.0.1",    # Adresse locale du serveur MySQL
port = 3306,           # Port par défaut pour MySQL
user = "root",         # Nom d'utilisateur
password = "less@intsARS19") # Mot de passe réel
# Vérification de la connexion
if (!is.null(con)) {
cat("Connexion réussie à la base de données 'mlearning' !\n")
} else {
cat("Erreur lors de la connexion.\n")
}
# Créer la colonne 'parameter_id' qui contient des valeurs de 1 à N
Output_Curves$parameter_id <- 1:nrow(Output_Curves)
# Préparer les données à insérer dans la table NormalData
for (i in 1:nrow(Output_Curves)) {
# Convertir la colonne Un en chaîne JSON
Un_json <- toJSON(Output_Curves$Un[[i]], auto_unbox = TRUE)  # auto_unbox pour convertir en un tableau JSON correct
# Construire la requête SQL
query <- sprintf("INSERT INTO NormalData (parameter_id, Un) VALUES (%d, '%s')",
Output_Curves$parameter_id[i], Un_json)  # '%s' pour insérer la chaîne JSON
# Exécuter la requête d'insertion
dbExecute(con, query)
}
# Créer la colonne 'parameter_id' qui contient des valeurs de 1 à N
Main_Learning_Base$parameter_id <- 1:nrow(Main_Learning_Base)
# Préparer les données à insérer dans la table NormalData
for (i in 1:nrow(Main_Learning_Base)) {
# Convertir la colonne Un en chaîne JSON
Un_j <- toJSON(Main_Learning_Base$Un[[i]], auto_unbox = TRUE)  # auto_unbox pour convertir en un tableau JSON correct
# Construire la requête SQL
query <- sprintf("INSERT INTO NoiseData (parameter_id, Un) VALUES (%d, '%s')",
Main_Learning_Base$parameter_id[i], Un_j)  # '%s' pour insérer la chaîne JSON
# Exécuter la requête d'insertion
dbExecute(con, query)
}
Generate_output(2,1,1,0.1,1)
Generate_output(2,1,1,0.1,1) + rnorm(3,mean=0,sd=1)
# Génération des résultats et création de la DataFrame
Main_Learning_Base <- data.frame(
a = sim_a,
b = sim_b,
c = sim_c,
U0 = sim_U0
)
# Calcul des sorties Un et ajout comme une colonne
Main_Learning_Base$Un <- lapply(1:nrow(Main_Learning_Base), function(i) {
# Générer les valeurs de Un avec Generate_output
generated_values <- Generate_output(N, Main_Learning_Base$a[i], Main_Learning_Base$b[i], Main_Learning_Base$c[i], Main_Learning_Base$U0[i])
# Ajouter le bruit uniquement aux valeurs Un (excluant U0)
noisy_values <- generated_values
noisy_values[-1] <- noisy_values[-1] + rnorm(N, mean = 0, sd = 1)
return(noisy_values)
})
# Génération des résultats et création de la DataFrame
Main_Learning_Base <- data.frame(
a = sim_a,
b = sim_b,
c = sim_c,
U0 = sim_U0
)
# Calcul des sorties Un et ajout comme une colonne
Main_Learning_Base$Un <- lapply(1:nrow(Main_Learning_Base), function(i) {
# Générer les valeurs de Un avec Generate_output
generated_values <- Generate_output(N, Main_Learning_Base$a[i], Main_Learning_Base$b[i], Main_Learning_Base$c[i], Main_Learning_Base$U0[i])
# Ajouter le bruit uniquement aux valeurs Un (excluant U0)
#noisy_values <- generated_values
generated_values[-1] <- generated_values[-1] + rnorm(N, mean = 0, sd = 1)
return(generated_values)
})
# Créer la colonne 'parameter_id' qui contient des valeurs de 1 à N
Main_Learning_Base$parameter_id <- 1:nrow(Main_Learning_Base)
# Préparer les données à insérer dans la table NormalData
for (i in 1:nrow(Main_Learning_Base)) {
# Convertir la colonne Un en chaîne JSON
Un_j <- toJSON(Main_Learning_Base$Un[[i]], auto_unbox = TRUE)  # auto_unbox pour convertir en un tableau JSON correct
# Construire la requête SQL
query <- sprintf("INSERT INTO NoiseData (parameter_id, Un) VALUES (%d, '%s')",
Main_Learning_Base$parameter_id[i], Un_j)  # '%s' pour insérer la chaîne JSON
# Exécuter la requête d'insertion
dbExecute(con, query)
}
# Créer la colonne 'parameter_id' qui contient des valeurs de 1 à N
Output_Curves$parameter_id <- 1:nrow(Output_Curves)
# Préparer les données à insérer dans la table NormalData
for (i in 1:nrow(Output_Curves)) {
# Convertir la colonne Un en chaîne JSON
Un_json <- toJSON(Output_Curves$Un[[i]], auto_unbox = TRUE)  # auto_unbox pour convertir en un tableau JSON correct
# Construire la requête SQL
query <- sprintf("INSERT INTO NormalData (parameter_id, Un) VALUES (%d, '%s')",
Output_Curves$parameter_id[i], Un_json)  # '%s' pour insérer la chaîne JSON
# Exécuter la requête d'insertion
dbExecute(con, query)
}
View(Main_Learning_Base)
set.seed(123)  # Pour la reproductibilité
# Nombre de simulations
M <- 100 # Ajustez ce nombre selon vos besoins
N <- 40   # Nombre d'itérations pour Generate_output
# Simulation des paramètres
sim_a <- round(rnorm(M, mean = 3, sd = 0.2), 2)  # Simulation des paramètres a
sim_b <- round(rnorm(M, mean = 4, sd = 0.3), 2)  # Simulation des paramètres b
sim_c <- round(rnorm(M, mean = 0.6, sd = 0.05), 2)  # Simulation des paramètres c
sim_U0 <- round(runif(M, min = 1, max = 10), 2)  # Simulation des valeurs initiales de U0
set.seed(123)  # Pour la reproductibilité
# Génération des résultats et création de la DataFrame
Output_Curves <- data.frame(
a = sim_a,
b = sim_b,
c = sim_c,
U0 = sim_U0
)
# Calcul des sorties Un et ajout comme une colonne
Output_Curves$Un <- lapply(1:nrow(Output_Curves), function(i) {
Generate_output(N, Output_Curves$a[i], Output_Curves$b[i], Output_Curves$c[i], Output_Curves$U0[i])
})
# Affichage de la DataFrame
head(Output_Curves)
# Génération des résultats et création de la DataFrame
Main_Learning_Base <- data.frame(
a = sim_a,
b = sim_b,
c = sim_c,
U0 = sim_U0
)
# Calcul des sorties Un et ajout comme une colonne
Main_Learning_Base$Un <- lapply(1:nrow(Main_Learning_Base), function(i) {
# Générer les valeurs de Un avec Generate_output
generated_values <- Generate_output(N, Main_Learning_Base$a[i], Main_Learning_Base$b[i], Main_Learning_Base$c[i], Main_Learning_Base$U0[i])
generated_values[-1] <- generated_values[-1] + rnorm(N, mean = 0, sd = 1)
return(generated_values)
})
param<-Main_Learning_Base[, 1:4]
# Créer la table Parameters
dbExecute(con, "
CREATE TABLE IF NOT EXISTS Parameters (
id INT AUTO_INCREMENT PRIMARY KEY,
a FLOAT NOT NULL,
b FLOAT NOT NULL,
c FLOAT NOT NULL,
U0 FLOAT NOT NULL
)
")
# Créer la table NormalData avec l'ID comme clé primaire et la clé étrangère pour parameter_id
dbExecute(con, "
CREATE TABLE IF NOT EXISTS NormalData (
id INT AUTO_INCREMENT PRIMARY KEY,  -- Définir id comme clé primaire
parameter_id INT NOT NULL,          -- Clé étrangère
Un JSON NOT NULL,                   -- Colonne JSON pour stocker Un
FOREIGN KEY (parameter_id) REFERENCES Parameters(id) ON DELETE CASCADE  -- Référence à Parameters
)
")
# Créer la table NoiseData
dbExecute(con, "
CREATE TABLE IF NOT EXISTS NoiseData (
id INT AUTO_INCREMENT PRIMARY KEY,
parameter_id INT NOT NULL,
Un JSON NOT NULL,
FOREIGN KEY (parameter_id) REFERENCES Parameters(id) ON DELETE CASCADE
)
")
# Préparer les données à insérer, en excluant l'`id`
for (i in 1:nrow(param)) {
query <- sprintf("INSERT INTO Parameters (a, b, c, U0) VALUES (%f, %f, %f, %f)",
param$a[i], param$b[i], param$c[i], param$U0[i])
dbExecute(con, query)
}
# Créer la colonne 'parameter_id' qui contient des valeurs de 1 à N
Output_Curves$parameter_id <- 1:nrow(Output_Curves)
# Préparer les données à insérer dans la table NormalData
for (i in 1:nrow(Output_Curves)) {
# Convertir la colonne Un en chaîne JSON
Un_json <- toJSON(Output_Curves$Un[[i]], auto_unbox = TRUE)  # auto_unbox pour convertir en un tableau JSON correct
# Construire la requête SQL
query <- sprintf("INSERT INTO NormalData (parameter_id, Un) VALUES (%d, '%s')",
Output_Curves$parameter_id[i], Un_json)  # '%s' pour insérer la chaîne JSON
# Exécuter la requête d'insertion
dbExecute(con, query)
}
# Créer la colonne 'parameter_id' qui contient des valeurs de 1 à N
Main_Learning_Base$parameter_id <- 1:nrow(Main_Learning_Base)
# Préparer les données à insérer dans la table NormalData
for (i in 1:nrow(Main_Learning_Base)) {
# Convertir la colonne Un en chaîne JSON
Un_j <- toJSON(Main_Learning_Base$Un[[i]], auto_unbox = TRUE)  # auto_unbox pour convertir en un tableau JSON correct
# Construire la requête SQL
query <- sprintf("INSERT INTO NoiseData (parameter_id, Un) VALUES (%d, '%s')",
Main_Learning_Base$parameter_id[i], Un_j)  # '%s' pour insérer la chaîne JSON
# Exécuter la requête d'insertion
dbExecute(con, query)
}
# Supposons que Main_Learning_Base est déjà chargé et contient M lignes
set.seed(123)  # Pour la reproductibilité
# Déterminer le nombre de lignes pour chaque ensemble
train_size <- floor(0.7 * M)  # 70% pour l'entraînement
test_size <- M - train_size     # 30% pour le test
# Échantillonner les indices pour l'ensemble d'entraînement
train_indices <- sample(1:M, size = train_size, replace = FALSE)
# Créer les ensembles d'entraînement et de test
Main_Training_Base <- Main_Learning_Base[train_indices, ]  # Ensemble d'entraînement
Main_Test_Base <- Main_Learning_Base[-train_indices, ]      # Ensemble de test
Main_Training_Base
View(Output_Curves)
length(param)
dim(param)
nrow(param)
nrow(param)+1
Uo <- c(7.18, 2.57, 3.87)
a1<-1.72
b1<-2.72
c1<-0.80
# Vérifier et mettre à jour la base
for (u0 in Uo) {
# Vérifier si les paramètres (a, b, c, U0) existent déjà dans `param`
existing_row <- param[param$a == a1 & param$b == b1 & param$c == c1 & param$U0 == u0, ]
if (nrow(existing_row) == 0) {  # Si les paramètres n'existent pas déjà
# Ajouter les paramètres dans `param`
new_param <- data.frame(a = a1, b = b1, c = c1, U0 = u0)
param <- rbind(param, new_param)
Nparam <-nrow(param)
# Générer la suite avec bruit
U_val_bruité <- Generate_output(N, a1, b1, c1, u0) + rnorm(N+1,mean=0,sd=1)
U <-U_val_bruité[-1]
# Ajouter les données dans Main_Learning_Base
new_row <- data.frame(a = a1, b = b1, c = c1, U0 = u0, Un=U,parameter_id=Nparam+1)
Main_Learning_Base <- rbind(Main_Learning_Base, new_row)
# Ajouter les données dans Output_Curves
# Générer la suite sans bruit
U_val <- Generate_output(N, a1, b1, c1, u0)
new_curve <- data.frame(a = a1, b = b1, c = c1, U0 = u0, Un=U_val,parameter_id=Nparam+1)
Output_Curves <- rbind(Output_Curves, new_curve)
}
}
U_val_bruité <- Generate_output(N, a1, b1, c1, u0) + rnorm(N+1,mean=0,sd=1)
U_val_bruité
U_val_bruité[-1]
U<-U_val_bruité[-1]
U
U<-list(U_val_bruité[-1])
U
Uo <- c(8.2, 1.57, 3.97)
a1<-1.72
b1<-2.72
c1<-0.80
# Vérifier et mettre à jour la base
for (u0 in Uo) {
# Vérifier si les paramètres (a, b, c, U0) existent déjà dans `param`
existing_row <- param[param$a == a1 & param$b == b1 & param$c == c1 & param$U0 == u0, ]
if (nrow(existing_row) == 0) {  # Si les paramètres n'existent pas déjà
# Ajouter les paramètres dans `param`
new_param <- data.frame(a = a1, b = b1, c = c1, U0 = u0)
param <- rbind(param, new_param)
Nparam <-nrow(param)
# Générer la suite avec bruit
U_val_bruité <- Generate_output(N, a1, b1, c1, u0) + rnorm(N+1,mean=0,sd=1)
U <-list(U_val_bruité[-1])
# Ajouter les données dans Main_Learning_Base
new_row <- data.frame(a = a1, b = b1, c = c1, U0 = u0, Un=U,parameter_id=Nparam+1)
Main_Learning_Base <- rbind(Main_Learning_Base, new_row)
# Ajouter les données dans Output_Curves
# Générer la suite sans bruit
U_val <- list(Generate_output(N, a1, b1, c1, u0))
new_curve <- data.frame(a = a1, b = b1, c = c1, U0 = u0, Un=U_val,parameter_id=Nparam+1)
Output_Curves <- rbind(Output_Curves, new_curve)
}
}
Uo <- c(8.2, 1.57, 3.97)
a1<-1.72
b1<-2.72
c1<-0.80
# Vérifier et mettre à jour la base
for (u0 in Uo) {
# Vérifier si les paramètres (a, b, c, U0) existent déjà dans `param`
existing_row <- param[param$a == a1 & param$b == b1 & param$c == c1 & param$U0 == u0, ]
if (nrow(existing_row) == 0) {  # Si les paramètres n'existent pas déjà
# Ajouter les paramètres dans `param`
new_param <- data.frame(a = a1, b = b1, c = c1, U0 = u0)
param <- rbind(param, new_param)
Nparam <-nrow(param)
# Générer la suite avec bruit
U_val_bruité <- Generate_output(N, a1, b1, c1, u0) + rnorm(N+1,mean=0,sd=1)
U <-list(U_val_bruité[-1])
# Ajouter les données dans Main_Learning_Base
new_row <- data.frame(a = a1, b = b1, c = c1, U0 = u0, Un=U,parameter_id=Nparam+1)
Main_Learning_Base <- rbind(Main_Learning_Base, new_row)
# Ajouter les données dans Output_Curves
# Générer la suite sans bruit
U_val <- list(Generate_output(N, a1, b1, c1, u0))
new_curve <- data.frame(a = a1, b = b1, c = c1, U0 = u0, Un=U_val,parameter_id=Nparam+1)
Output_Curves <- rbind(Output_Curves, new_curve)
}
}
Uo <- c(8.2, 1.57, 3.97)
a1<-1.72
b1<-2.72
c1<-0.80
# Vérifier et mettre à jour la base
for (u0 in Uo) {
# Vérifier si les paramètres (a, b, c, U0) existent déjà dans `param`
existing_row <- param[param$a == a1 & param$b == b1 & param$c == c1 & param$U0 == u0, ]
if (nrow(existing_row) == 0) {  # Si les paramètres n'existent pas déjà
# Ajouter les paramètres dans `param`
new_param <- data.frame(a = a1, b = b1, c = c1, U0 = u0)
param <- rbind(param, new_param)
Nparam <-nrow(param)
# Générer la suite avec bruit
U_val_bruité <- Generate_output(N, a1, b1, c1, u0)
U_val_bruité[-1]<-U_val_bruité[-1]+ rnorm(N,mean=0,sd=1)
U <-list(U_val_bruité)
# Ajouter les données dans Main_Learning_Base
new_row <- data.frame(a = a1, b = b1, c = c1, U0 = u0, Un=U,parameter_id=Nparam+1)
Main_Learning_Base <- rbind(Main_Learning_Base, new_row)
# Ajouter les données dans Output_Curves
# Générer la suite sans bruit
U_val <- list(Generate_output(N, a1, b1, c1, u0))
new_curve <- data.frame(a = a1, b = b1, c = c1, U0 = u0, Un=U_val,parameter_id=Nparam+1)
Output_Curves <- rbind(Output_Curves, new_curve)
}
}
Uo <- c(8.2, 1.57, 3.97)
a1<-1.72
b1<-2.72
c1<-0.80
# Vérifier et mettre à jour la base
for (u0 in Uo) {
# Vérifier si les paramètres (a, b, c, U0) existent déjà dans `param`
existing_row <- param[param$a == a1 & param$b == b1 & param$c == c1 & param$U0 == u0, ]
if (nrow(existing_row) == 0) {  # Si les paramètres n'existent pas déjà
# Ajouter les paramètres dans `param`
new_param <- data.frame(a = a1, b = b1, c = c1, U0 = u0)
param <- rbind(param, new_param)
Nparam <-nrow(param)
# Générer la suite avec bruit
U_val_bruité <- Generate_output(N, a1, b1, c1, u0)
U_val_bruité[-1]<-U_val_bruité[-1]+ rnorm(N,mean=0,sd=1)
U <-list(U_val_bruité)
# Ajouter les données dans Main_Learning_Base
new_row <- data.frame(a = a1, b = b1, c = c1, U0 = u0, Un=U,parameter_id=Nparam+1)
Main_Learning_Base <- rbind(Main_Learning_Base, new_row)
# Ajouter les données dans Output_Curves
# Générer la suite sans bruit
U_val <- list(Generate_output(N, a1, b1, c1, u0))
new_curve <- data.frame(a = a1, b = b1, c = c1, U0 = u0, Un=U_val,parameter_id=Nparam+1)
Output_Curves <- rbind(Output_Curves, new_curve)
}
}
str(Main_learning_Base)
str(Main_Learning_Base)
Uo <- c(8.21, 1.572, 3.197)
a1<-1.72
b1<-2.72
c1<-0.80
# Vérifier et mettre à jour la base
for (u0 in Uo) {
# Vérifier si les paramètres (a, b, c, U0) existent déjà dans `param`
existing_row <- param[param$a == a1 & param$b == b1 & param$c == c1 & param$U0 == u0, ]
if (nrow(existing_row) == 0) {  # Si les paramètres n'existent pas déjà
# Ajouter les paramètres dans `param`
new_param <- data.frame(a = a1, b = b1, c = c1, U0 = u0)
param <- rbind(param, new_param)
Nparam <-nrow(param)
# Générer la suite avec bruit
U_val_bruité <- Generate_output(N, a1, b1, c1, u0)
U_val_bruité[-1]<-U_val_bruité[-1]+ rnorm(N,mean=0,sd=1)
# Ajouter les données dans Main_Learning_Base
new_row <- data.frame(a = a1, b = b1, c = c1, U0 = u0, Un = I(list(U_val_bruité)), parameter_id = Nparam)
Main_Learning_Base <- rbind(Main_Learning_Base, new_row)
# Générer la suite sans bruit
U_val <- Generate_output(N, a1, b1, c1, u0)
# Ajouter les données dans Output_Curves
new_curve <- data.frame(a = a1, b = b1, c = c1, U0 = u0, Un = I(list(U_val)), parameter_id = Nparam)
Output_Curves <- rbind(Output_Curves, new_curve)
}
}
